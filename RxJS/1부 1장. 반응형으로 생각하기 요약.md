####  **확장성(scalability)** 의 문제

사용자가 늘어나 데이터를 많이 받을수록 애플리케이션이 사용하거나 필요한 메모리의 양은 선형으로 증가하며 최악의 경우엔 기하급수로 증가한다. 받은 데이터를 모두 동시에 처리하려고 하면 UI가 정상적으로 응답하지 않게 된다. 최근 몇 년 동안 자바스크립트 애플리케이션이 처리해야 하는 이벤트와 데이터의 수가 급격히 증가, 데이터의 크기가 커져 바로 사용하거나 메모리에 저장해 사용하기가 어려워졌다. 따라서 데이터를 원격 장소에 저장하고 비동기로 가져와 사용하는 방법을 도입했다. 그러나 이때는 코드에서 표현되지 않는 **지연 시간(latency)** 문제가 발생한다. 이는 코드에서 표현하기 어려울 수 있다.

#### **지연 시간 (latency)** 문제

현대 시스템 구조가 빠른 네트워크와 고도의 동시 처리 기능을 갖추며 성능이 크게 좋아졌지만 원격 데이터의 복잡성을 처리하는 라이브러리와 메서드들은 같은 수준으로 발전하지 못했다. 서버에서 데이터를 가져오거나 지연된 계산을 실행하는 경우 대부분 콜백 패턴에 의존한다. 그러나 콜백 패턴은 비즈니스 로직이 발전하고 변경될 때, 하나의 문제에서 여러 서버에 있는 데이터를 사용할 때 급격히 깨져버린다.

- 현재 비동기 해결책의 한계점을 살펴본다.
- RxJS가 이터레이터(iterator)와 옵저버(observer)를 사용해 구현한 스트림(stream) 관점으로 생각할 수 있는 방법을 배운다.
- 콜백 사용과 상관 없는 RxJS 비동기 코드 작성의 이점을 살펴본다.

## 1.1. 동기 연산 vs 비동기 연산

동기와 비동기 코드의 런타임(실행 시간)을 구분하는 요소는 **대기 시간(wait time)**이라고도 하는 **지연 시간(latency)**이다.

#### 블로킹 코드 문제

자바스크립트는 단일 스레드를 사용하므로 블로킹을 사용해 동기적으로 프로세스를 실행하는 경우 사용자 이벤트가 발생할 때마다 애플리케이션이 블로킹되게 된다. 이러한 문제를 논블로킹 방식으로 해결하기 위해 자바스크립트는 콜백 함수를 제공한다.

#### 콜백 함수와 논블로킹 코드

싱글 스레드 언어인 자바스크립트는 오랫동안 함수를 콜백으로 사용해왔다. 마우스 클릭과 키 입력 이벤트부터 원격 HTTP 요청, 파일 입출력까지 모든 부분에서 콜백 함수를 사용한다.

즉, 콜백 함수는 **데이터를 사용할 준비가 되면 자바스크립트 런타임에 호출할 처리 함수를 제공해 장기 실행 작업의 블로킹 문제를 해결**하기 위해 만들어졌다. 

무조건 대기하는 블로킹 HTTP 호출 방식과 달리 비동기(AJAX) 요청과 함께 콜백 함수를 사용하면 애플리케이션이 다음 코드를 실행하는 제어의 역전(inversion of control)이 발생한다. 제어의 역전이랑 코드의 특정 부분이 런타임 시스템에서 제어의 흐름을 되돌려받는 방식을 말한다. 즉, 콜백 함수가 데이터를 처리할 준비가 되면 런타임이 함수 처리기를 통해 애플리케이션을 다시 호출하거나 제어권을 **돌려준다**. 이런 특징 때문에 콜백(callback)이라고 한다.

```javascript
ajax('/data', // 1. AJAX 호출
    items => items.forEach(item => { /* ... */})); // 3. 서버에서 데이터를 가져온 후 콜백함수 호출
beginUiRendering(); // 2. beginUiRendering 호출
```

위 코드에서 HTTP 함수는 백그라운드에서 실행되고 호출자(애플리케이션)에게 즉시 제어권을 반환해 UI 렌더링을 시작한다.

#### 1.1.3. 시간과 공간 이해하기

프로그램에서 상태란 어느 시점에서 변수들에 저장된 정보의 스냅샷이다. 동기 코드에서는 변수의 상태와 다음에 발생할 상황을 쉽게 예측할 수 있어 코드 작성과 디버깅이 쉽다. 그러나 작업의 대기 시간과 완료 시간이 각각 다른 비동기 코드는 특정 시점에서의 상태를 정확하게 예측하기 어렵다.

비동기 실행에서는 처음 호출된 함수가 두번째 호출된 함수보다 일찍 끝난다는 보장이 없다. 차례로 호출되는 비동기 함수들이 독립적이라면 실행 순서가 상관 없지만, 이 작업들이 하나의 전역 상태를 공유하는 함수라면 문제가 발생한다. 이런 상태를 **부가 작용(side effect)**이라고 부르며 이를 억제하기 위해 함수형 프로그래밍과 반응형 프로그래밍에서는 **순수 함수(pure function)**를 사용해 불안정성을 최소화 한다.

그러나 사용하는 함수에 side effect가 없다고 해도 여전히 시간 문제가 남아있다. 각 단계가 올바른 순서대로 실행되게 어떻게 보장하느냐다. 전통적인 방법으로는 콜백을 중첩하는 패턴이다. 중첩 콜백 패턴은 결과를 추론하기가 훨씬 어렵다.

#### 1.1.4. 반응형 사고에서 콜백을 사용하지 않아야 할까

아니다. 사용자 또는 외부 서비스와의 간단한 상호작용을 처리할 때는 RxJS가 과하고, 콜백이 좋다. 함수형과 반응형 패러다임이 혼합된 라이브러리는 동적 UI 또는 서비스 조율과 같이 중간 정도 복잡성을 가진 상태 시스템을 구현할 때 효과를 낸다. 복잡한 UI를 가진 애플리케이션에서 콜백 헬은 유지보수성을 떨어뜨린다. 특히 콜백 함수에서 반복문을 사용할 경우 호출에 지연 시간이 있음을 인식하지 못해 문제가 생겨도 항상 다음 루프를 진행하므로 루프 대신 forEach()와 같은 메서드를 사용해 비동기 함수를 클로저로 만들어야 한다.

## 1.2. Promise로 더 나아진 콜백

자바스크립트는 ES6에서 미래에 완료될 것으로 예상되는 비동기 계산을 나타내려고 Promise를 도입했다. Promise를 사용하면 일련의 작업을 미래의 값과 연결해서 continuation을 구현할 수 있다. Continuation(콜백)은 함수가 무작정 반환값을 기다리지 않고 다음에 수행할 작업을 결정하게 한다. 그러나 콜백이 중첩되면 코드를 예측하기 어렵다. 

그래서 'X를 실행한 다음 (then) Y를 실행하라'는 then의 개념이 도입되었다. Promise는 비동기와 장기 실행 연산, 결과나 에러를 구독할 수 있는 미래의 값을 래핑한 데이터 유형이다. 기본 작업이 완료되어 계산된 값을 구독자(subscriber)가 받게될 때 프로세스가 완료된 것으로 간주한다. 

```javascript
getItems()
	.then(items => items.map(getInfo))
	.then(promises => Promise.all(promises))	// Promise.all을 사용해 각각의 Promise를 하나의 결과 배열로 매핑
	.then(infos => infos.map(promises))
	.then(promises => Promise.all(promises))
	.then(processFiles);
```

then()은 해당 호출 사이에 시간이 포함되어 있음을 명시적으로 나타내는 좋은 기능이다. 그러나 Promise는 마우스 이벤트나 파일 스트림의 바이트 시퀀스처럼 둘 이상의 값을 생성하는 데이터 소스를 처리할 수 없다. 또한 RxJS에는 있는 에러 발생 시 작업을 재실행하는 기능이 Promise에는 없다. 가장 결정적인 단점은 Promise는 불변이라 취소할 수 없다는 것이다.

## 1.4. RxJS 이해하기

RxJS(Reactive Extentions for JavaScript)는 파일 읽기, HTTP 호출, 키 입력이나 마우스 이벤트 등 흔한 이벤트 소스를 처리하는 **단일 프로그래밍**을 사용해 콜백 + Promise로 해왔던 것들을 한 번에 해결한다.

#### 1.4.1. 스트림 측면에서 생각하기: 데이터의 흐름과 전파

RxJS에서는 키 입력, 움직임 이벤트, HTTP 호출, 정수 연산 등 모든 데이터 소스를 데이터 스트림(data stream)으로 다룬다.

```pseudocode
A$ = [20];	// A 스트림을 20으로 초기화
B$ = [30];	// B 스트림을 30으로 초기화
C$ = A$.concat(B$).reduce(adder); // [50] --- 50을 담은 새 컨테이너를 얻기 위해 두 스트림을 연결하고 adder 함수 적용
A$.push(100);	// A$에 새 값 주입
C$ = ?
```

스트림은 배열과 매우 유사한 데이터의 컨테이너(래퍼)니다. 따라서 배열의 리터럴 표기법인 `[]`로 나타낸다. 또한 스트림을 가리키는 변수는 접미사 `$`를 사용하는 게 일반적이다. 이 표기법은 RxJS 커뮤니티의 주요 공헌자인 핀란드인 안드레 스탈츠가 만들어 핀란드 표기법(Finnish Notation)이라고 한다.

값 100이 A$에 주입되면 C$는 어떻게 될까? 명령형 프로그래밍에서는 A$의 값이 바뀌어도 C$의 값에 영향을 주지 않는다. 하지만 변화의 전파(propagation of change)가 있는 스트림 세계에서는 A$가 새로운 값을 받으면(새로운 이벤트) 이 상태는 A$가 속한 모든 스트림을 통해 주입된다. 따라서 C$는 130이라는 값을 얻는다. 

**RP는 데이터의 흐름과 전파를 중심**으로 한다. 스트림은 모든 변화에 반응하고 구성 요소가 변경될 때마다 액션이 발생하는 상시 변수이다.

#### 1.4.2. RxJS 프로젝트

RxJS는 비동기 프로그래밍의 문제를 해결하고자 마이크로소프트의 Rx.Net으로부터 포팅한 오픈 소스 프레임워크이다. RxJS는 비동기 데이터를 단순 배열의 동기 데이터 소스처럼 처리하고자 추상화를 제공한다. RxJS를 스트림 측면에서 생각해보자.

![image](https://user-images.githubusercontent.com/48080762/86860089-29480280-c0ff-11ea-9f1d-e6ef6ec7adb5.png)

- 파이프 라인: 데이터를 사용할 수 있을 때 순서대로 실행되는 로직 영역
- 데이터 소스: 그림 왼쪽에 애플리케이션에서 소비될 다양한 형태의 데이터를 생산하는 데이터 소스가 있다.
- 사용자: 그림 오른쪽의 데이터 소비자. 데이터를 차트에 표시하거나 파일에 저장하는 등 이벤트를 구독하는 개체.

#### 1.4.3. 모든 것이 스트림이다

스트림의 개념은 원격 HTTP 호출에서 받은 바이트 데이터부터 단일 정수까지 **값을 가진 모든 데이터 요소에 적용할 수 있다**. RxJS는 스트림을 구독하고 관리하기 위해 일급 객체로 데이터를 전달하고, 다른 스트림들과 결합할 수 있는 경량 데이터 타입을 제공한다.

스트림은 스트림을 관찰하는 구독자(Observer)가 있을 때까지 아무 일도 하지 않는다. (생성되자마자 작업을 실행하는 Promise와는 다름) 스트림은 구독자가 연결된 후에만 실행하므로 지연(lazy) 데이터 타입이라 볼 수 있다. 스트림은 구독자로부터 구독되어 구독자가 값을 받게 되면 완료된다.

![image](https://user-images.githubusercontent.com/48080762/86860685-47623280-c100-11ea-80e7-fb1677597080.png)

파이프라인은 주어진 입력을 원하는 출력으로 변환하는 비즈니스 로직이 실행되는 곳이다.

#### 1.4.5. Rx 스트림의 컴포넌트

- 생산자
- 소비자
- 데이터 파이프라인
- 시간

#### 생산자

생산자(Producer)는 데이터의 소스이다. 스트림에는 항상 데이터 생산자가 있어야 하고, 데이터 생산자는 RxJS에서 수행할 모든 로직의 시작점이 된다. 생산자는 독립적으로 이벤트를 생성하는 무언가에서 생성된다. 이런 생산자를 옵저버 패턴에서는 **서브젝트(Subject)**라고 정의하고, RxJS에서는 관찰될 수 있는 무언가라는 의미로 **옵저버블(Observable)**이라고 부른다. 옵저버블은 이벤트를 방출해 알림을 푸시하기만 하고 **이벤트의 처리에는 관여하지 않는다**. 이런 동작을 fire-and-forget이라고 부른다.

#### 소비자

생산자로부터 이벤트를 받아들여 특정 방식으로 이벤트를 처리하는 소비자(Consumer). 소비자가 소비할 이벤트에 대해 생산자를 구독하기 시작하면 스트림이 생기게 되고, 이 시점에서 스트림은 이벤트를 푸시하기 시작한다. 소비자는 **옵저버(Observer)**라고 부른다.

스트림은 생산자 -> 소비자로만 이동한다. 사용자가 키보드 키를 누르면 다른 프로세스에서 소비되려고 흘러가는 이벤트를 생산하게 된다. 즉, 스트림 측면에서 생각하려면 데이터가 흐르는 방향을 결정하기 위해 애플리케이션을 업스트림과 다운스트림으로 생각해야 한다. RxJS와 관련해서 스트림은 항상 업스트림 옵저버블에서 다운스트림 옵저버블로 흐른다. 그리고 두 컴포넌트는 느슨한 결합으로 애플리케이션의 모듈성을 향상한다.

![image](https://user-images.githubusercontent.com/48080762/86861369-e89db880-c101-11ea-95b6-d06bff0da5b8.png)

예를 들어 키보드 이벤트 핸들러는 이벤트를 생성만 하고 소비하지 않으므로 업스트림, 반면 키 입력을 기반으로 로직을 수행해야 하는 코드는 다운스트림이다.











