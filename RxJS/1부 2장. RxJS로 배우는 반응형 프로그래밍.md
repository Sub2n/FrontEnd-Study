## 2.1. 반응형 프로그래밍의 기초인 함수형 프로그래밍

RP를 지원하는 추상화는 FP 위에 구축되므로 RP의 기본이 되는 FP를 이해해야 한다.

> ReactiveX는 옵저버 패턴과 이터레이터 패턴, 그리고 함수형 프로그래밍에서 나온 최상의 아이디어를 조합한 것입니다.
>
> _ReactiveX 프로젝트 사이트

1장에서 옵저버 패턴의 주요 컴포넌트(생산자와 소비자)를 배웠고, 이번에는 Rx 프로젝트를 구현하는 FP와 이터레이터를 알아본다.

#### 2.1.1. 함수형 프로그래밍

FP는 함수로 **선언적**이고 **불변**하며 **부수 효과(side effect)가 없는** 프로그램을 만드는 소프트웨어 패러다임이다. 불변(immutable)이란 상태가 변경되지 않는다는 뜻이다.

RxJS는 FP에서 **함수 체이닝(function chain)**과 **지연 평가(lazy evaluation)**, 데이터 흐름을 조정하기 위한 추상 데이터 타입 사용 개념을 차용했다. 

- **선언적(declarative)**: 함수형 코드는 비즈니스 로직을 적용하기 위해 자바스크립트의 고차 함수를 활용한다. 파이프라인이라고도 불리는 함수 체인은 데이터의 변환 단계를 묘사한다. SQL 구문이 선언적 코드의 완벽한 예시이다.

- **불변성(immutable)**: 불편 프로그램은 데이터를 생성한 후나 변수가 선언된 후에 이를 변경하거나 수정하지 않는 프로그램이다. 데이터의 수정이 일어나는 대신 새로운 데이터를 만들어 할당하게 된다.

- **부수 효과 없음(side effect free)**: 부수 효과가 있는 함수는 지역 스코프 밖에 있는 데이터에 영향을 받아 결과가 달라진다. 함수의 스코프는 전달받는 인수와 함수 내에서 선언된 지역 변수여야 한다. 이 영역을 넘어서는 작업(파일 읽기, 콘솔 출력, HTML페이지에 요소 렌더링 등)은 부수 효과로 간주하고 피하거나 최소한으로 해야 한다.

  객체지향 프로그래밍에서는 상태를 캡슐화해서 보호하는 반면 FP는 애초에 부수 효과를 일으키지 않는 순수 함수(pure function)를 이용해 프로그래밍한다.

자바스크립트는 변수의 불변성을 보장하는 const 키워드,  map, reduce, filter 등의 고차 함수로 배열 데이터 구조를 지원한다. for 루프를 사용하지 않고 배열의 고차함수를 사용하면 연산을 추상화하고 목적을 명확하게 기술해 프로그램의 **용도가 아닌 기능(how가 아니라 what)**을 설명하는 **선언적 프로그래밍**을 할 수 있다.

```javascript
const isEven = num => num % 2 === 0;
const squre = num => num * num;
const add = (a, b) => a + b;
const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const result = arr.filter(isEven).map(squre).reduce(add); // 220
```

위 연산은 부가 작용이 없어 언제나 동일한 입력에 동일한 값을 생성한다. FP의 중점을 루프를 사용하지 않고 프로그래밍하는 것이다. map, filter, reduce로 반복문을 숨겨 로직을 구현하면 원래 배열은 유지한 채 새로운 배열을 만들어 불변성을 유지하고 부수 효과가 없으며, 선언적이라는 목적을 달성할 수 있다. 다음 RxJS 추상 코드를 살펴보자.

```javascript
Stream([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
	.filter(isEven)
	.map(squre)
	.reduce(add)
	.subscribe(console.log); // 220
```

위 코드를 보면 Rx가 FP에서 어떻게 영감을 받았는지 명확하게 알 수 있다. 배열을 스트림으로 래핑한 다음, 연산 로직을 스트림의 파이프라인에 구현하고 값을 전달받기 위해서 스트림을 구독한다. 즉, 스트림은 데이터(이벤트)를 컨텍스트로 가져와서 원하는 값에 도달할 때까지 데이터에 작업을 수행하는 컨테이너이다. 

> 같은 강물에 두 번 발을 담글 수는 없다. 
>
> _ 헤라클레이토스

모든 것은 끊임 없이 움직인다는 변화화 움직임에 관한 깨달음은 RxJS 스트림에 관한 모든 것을 담고 있다고 볼 수 있다. 데이터는 끊임없이 흐르고 스트림을 통해 이동한다. **스트림은** 동적이지만 **불변 데이터 타입**이다. 한 번 선언된 스트림에는 나중에 값을 변경하거나 새로 추가할 수 없다. 그래서 **객체나 값의 동적인 동작은 선언적이고 불변하게 지정**한다.

따라서 파이프라인에 선언되는 비즈니스 로직은 부수 효과가 없는 순수 함수들이다. 또한 데이터 조작을 따로 빼내서 자연스럽게 관심사의 분리를 실현한다.

![image](https://user-images.githubusercontent.com/48080762/87260850-ce435080-c4ee-11ea-9a26-f677cd6c9366.png)

FP에서 차용한 또 다른 원칙은 **지연 평가(lazy evaluation)**로, 지연 평가는 코드가 실제로 필요할 때까지 호출되지 않는 것을 말한다. 즉, **함수는 그 결과가 다른 표현식에서 사용되기 전까지는 계산되지 않는다.** 스트림이 구독되기 전까지는 선언만 되어있고, 구독이 시작되면 생산자에서 소비자로 파이프라인을 통해 데이터를 흘려보낸다.

공부해야지~