## 7.1. 서비스란?

컴포넌트는 화면을 구성하는 뷰를 생성하고 관리하는 것이 주된 역할이다. 하지만 컴포넌트를 작성하다보면 주 관심사 이외의 부가적인 기능 (logging, 서버 통신 기능 등)이 필요하게 된다. 이러한 부가적인 기능을 컴포넌트 내에 작성하면 기능이 변경되었을 때 컴포넌트를 변경해야 하고 재사용이 어려워진다.

컴포넌트의 주요 관심사 외의 부가적인 기능은 애플리케이션 전역의 관심사인 경우가 많다. 이러한 경우, 컴포넌트의 관심사와 애플리케이션 전역의 관심사를 분리하는 것이 필요한데 이때 사용하는 것이 서비스(Service)이다. 애플리케이션 전역의 관심사를 서비스로 분리해 외부에서 관리하면 컴포넌트는 자신의 관심사에 집중해 복잡도가 낮아지고, 서비스는 재사용이 가능하게 되어 일관된 애플리케이션 코드를 작성할 수 있다.

## 7.2. 의존성 주입

Service는 Dependency Injection이 가능한 class이다. @Injectable 데코레이터로 정의한다.

Dependency Injection이란 말 그대로 의존성(dependency)을 주입(inject)한다는 것이다.

어떤 Component에서 Service의 method를 사용하는 경우 둘은 **의존 관계(Dependency relationship)**에 있다고 한다. Component 내부에서 Service class의 instance를 생성하는 경우 둘은 **강한 결합(Tight Coupling)**을 하고 있는 것이다. 반면 Component에서 직접 Service를 생성하는 것이 아니라 constructor의 parameter로 선언하여 Angular가 생성한 Service instance를 주입받는 것은 **느슨한 결합(Loose Coupling)**이다.

Tight Coupling은 많은 문제를 일으킨다. 하나의 Service의 생성 방법 등에 변동이 있을 경우 해당 Service와 의존 관계에 있는 모든 Component가 영향을 받는다.

재사용과 유지보수가 효율적인 프로그램을 만들기 위해서는 객체 사이의 **의존 관계를 최소화**해야 한다. 필요에 의해 의존 관계가 있을 경우 Tight Coupling은 지양해야 한다.

Dependency Injection은 Design pattern 중 하나로, tight coupling에서 loose coupling으로 전환하는 방법이다.

```typescript
class A {
  // dependency의 instance를 직접 생성하지 않고 외부 환경에 요구
  constructor(private dependency: B) {
  }

  foo() { this.dependency.bar(); }
}

class B {
  bar() { console.log('bar'); }
}
```

A class처럼 constructor에서 instance를 parameter로 받는 경우, A class에서는 해당 instance의 생성 방법을 알 필요가 없다.

```typescript
// greeting.service.ts
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root' /* @Injectable 프로바이더 */
})
export class GreetingService {
  sayHi() { return 'Hi!'; }
}
```

Angular에서 Dependency Injection을 받기 위해서는 @Injectable 데코레이터에 meta data로 `providedIn: 'root'`를 설정해야 한다. 해당 선언이 된 Service는 전역에서 Injectable하다.

또는 해당 Service를 주입받을 Component에서 @Compinent 데코레이터에 meta data로 `providers: [GreetingService]`를 설정해주면 된다. 이 Component를 포함한 Child component 들에서만 Injectable하다.



## 7.3. 인젝터와 인젝터 트리

### 7.3.1. 인젝터

Angular는 의존성 주입 요청에 의해 주입되어야 할 인스턴스가 있다면 인스턴스의 주입을 Injector에 요청한다. 인젝터는 Component와 Module 레벨로 존재하며 의존성 주입 요청에 의해 Provider를 검색하고 인스턴스를 생성해 의존성 인스턴스를 주입한다.

의존성 요청이 있을 때마다 매번 인스턴스를 생성하는 것은 아니고, Injector는 인스턴스의 pool인 Container를 관리한다. Injector는 의존성 주입 요청을 받으면 Provider를 참조해 요청된 인스턴스가 Container에 존재하는지 검색한다. 이 때 사용하는 것이 Provider의 `provide 프로퍼티값인 토큰`이다. 기존에 생성된 인스턴스는 Provider의 토큰을 키로 Container에 저장되어 있다. 인스턴스를 검색할 때는 토큰을 키로 검색한다.

```typescript
providers: [{
  // 의존성 인스턴스의 타입 (토큰)
  provide: GreetingService,
  // 의존성 인스턴스를 생성할 클래스
  useClass: GreetingService
}]
```

주입 요청 받은 인스턴스가

- Container에 존재하면 : 존재하는 인스턴스를 주입
- Container에 존재하지 않으면 : Provider의 useClass 프로퍼티를 참조해 인스턴스를 생성하고 토큰을 키로 Container에 추가하 후, 인스턴스를 constructor에 주입

### 7.3.2. 인젝터 트리

Component는 트리 구조로 구성된다. 모든 Component는 하나의 Injector를 가지므로 Component 트리 구조와 동일한 Injector 트리 또한 만들어진다.

컴포넌트의 주입 요청이 있을 때 Angular는 해당 컴포넌트의 Injector에게 의존성 주입을 요청한다. 이때 해당 컴포넌트의 Injector는 주입 대상의 Provider가 컴포넌트에 등록되어 있는지 검색한다. 예를 들어 아래와 같은 의존성 주입 요청이 있다고 하자.

```typescript
contsructor(private user: UserService) {}
```

1. 의존성 주입을 요청한 컴포넌트의 Injector에 주입을 요청
2. 주입을 요청받은 Injector는 컴포넌트에서 UserService를 토큰으로 갖는(provide 프로퍼티값이 UserService인) Provider를 찾음
3. 만약 Provider를 못 찾으면 상위 컴포넌트의 Injector로 의존성 주입 요청. 찾을 때까지 반복
4. 만약 최상위 컴포넌트에서 못 찾으면 모듈에서 Provider 검색. 아무데서도 못 찾으면 에러 발생
5. Provider를 찾으면 해당 Provider를 사용해 인스턴스를 주입

## 7.4. 프로바이더

의존성 주입을 위해서 Angular에 주입 대상 인스턴스를 어떻게 생성하는지에 대한 정볼르 알려줘야 한다. **이 인스턴스 생성 정보를 통해 의존성 인스턴스의 생성을 지시하는 것을 Provider**라고 부르며, 모듈의 @NgModule이나 컴포넌트의 @Component 메타데이터 객체의 providers 프로퍼티에 등록한다.

```typescript
@NgModule({
  providers: [GreetingService]
})
```

```typescript
@Component({
  providers: [GreetingService]
})
```

@Injectable 메타데이터 객체의 provideIn 프로퍼티를 사용한 Provider 설정 방식이 Angular 6에서 새롭게 도입됐다. provideIn 프로퍼티 값으로 'root'를 설정하면 root Injector에게 서비스를 제공하도록 지시해 애플리케이션의 모든 구성요소에 Singleton 전역 서비스를 주입할 수 있도록 한다. 이는 루트 모듈에 Provider를 등록한 것과 동일하게 동작한다.

```typescript
@Injectable({
  provideIn: 'root'
})
```

```typescript
@Injectable({
  provideIn: UserModule
})
```

모듈에 프로바이더를 등록한 서비스는 해당 모듈의 모든 구성요소(루트 모듈의 경우 애플리케이션 전역)에 주입할 수 있고, 컴포넌트에 프로바이더를 등록한 서비스는 해당 컴포넌트와 하위 컴포넌트에 주입할 수 있다.

서비스는 Injector의 주입 범위 내에서 언제나 Singleton이다. 그러나 컴포넌트의 Injector는 독립적으로 동작한다. 예를 들어 루트 모듈의 Injector가 제공하는 서비스가 있을 때, 같은 Provider를 컴포넌트에 등록하면 해당 컴포넌트와 하위 컴포넌트에는 2개의 서비스가 주입될 수 있다.

Provider는 사용 방법에 따라 3가지 종류로 구분할 수 있다.

- Class Provider
- Value Provider
- Factory Provider

### 7.4.1. Class Provider

Class Provider는 가장 일반적인 provider로 클래스의 인스턴스를 의존성 주입하기 위한 설정을 등록한다. providers 프로퍼티는 제공할 인스턴스의 클래스 리스트로 구성된 배열을 값으로 갖는다.

```typescript
providers: [GreetingService]
```

이는 실제로 두 개의 프로퍼티를 가진 객체 리터럴을 사용해 Provider를 등록하는 것을 축약 표현한 것으로 아래와 동일한 표현이다.

```typescript
providers: [{
  provide: GreetingService,	// 토큰
  useClass: GreetingService // 의존성 인스턴스를 생성할 클래스
}]
```

첫 번째 provide 프로퍼티는 Injector가 관리하고 있는 컨테이너에서 주입 요청 받은 인스턴스를 검색하거나 생성한 인스턴스를 등록할 때 키 역할을 하는 토큰이며 일반적으로 주입 대상 인스턴스의 타입을 지정한다.

두 번째 useClass 프로퍼티는 주입 대상 인스턴스를 생성하는 클래스(provider definition object)를 의미한다. Injector는 주입 요청 받은 인스턴스를 컨테이너에서 검색할 수 없어서 인스턴스를 생성해야할 때 이 클래스를 사용한다.











































































