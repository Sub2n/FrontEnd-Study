# 스코프

변수는 자신이 **선언된 위치에 의해 스코프가 결정**된다.

스코프는 자바스크립트 엔진이 참조할 **변수를 검색할 때 사용하는 규칙**이다.

실행 컨텍스트 - 렉시컬 환경의 OuterLexicalEnvironmentReference를 통해서 스코프체인을 구현한다.

한 스코프 안에서 식별자의 이름은 중복될 수 없다. 이는 다른 스코프 내에서는 같은 이름의 식별자를 사용할 수 있음을 의미한다. 

## 스코프의 종류

| 구분 | 설명                  | 스코프      | 변수      |
| :--: | :-------------------- | :---------- | :-------- |
| 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역 변수 |
| 지역 | 함수 몸체 내부        | 지역 스코프 | 지역 변수 |

## 스코프 체인

![img](https://poiemaweb.com/assets/fs-images/12-3.png)

**스코프는 함수의 중첩에 의해 계층적 구조를 갖는다**

최상위 스코프는 전역 스코프이다.

> ##### 렉시컬 환경(Lexical Environment)
>
> 스코프 체인은 실행 컨텍스트(Execution Context)의 렉시컬 환경(Lexical Environment)을 연결(Channing)한 것이다. 전역 렉시컬 환경은 코드가 로드되고 곧바로 생성되고 함수의 렉시컬 환경은 함수가 호출되고 곧바로 생성된다. 

## 스코프가 식별자를 검색하는 규칙

변수를 참조하는 코드가 속한 스코프에서부터 상위 스코프 방향으로 이동하며 변수를 검색한다.

따라서 **상위 스코프의 식별자는 참조할 수 있지만 하위 스코프의 변수는 참조할 수 없다**.



## 함수 / 블록 레벨 스코프와 var / let, const

`var` 키워드로 선언한 변수는 함수 레벨 스코프만을 지원한다.

`let`, `const` 키워드로 선언한 변수는 블록 레벨 스코프를 지원한다.

블록 레벨 스코프를 지원하지 않는다는 것은 if문 등에서 스코프가 인정되지 않는다는 것이다. 다음과 같은 문제를 발생시킨다.

```javascript
var x = 1;

if (true) {
  // var 키워드로 선언된 변수는 함수의 코드 블록 만을 지역 스코프로 인정한다.
  // 함수 밖에서 선언된 변수는 코드 블록 내에서 선언되었다 할 지라도 모두 전역 변수이다.
  // 따라서 x는 전역 변수이다. 이미 선언된 전역 변수 x가 있으므로 변수 x는 중복 선언된다.
  // 이는 의도치 않게 변수값이 변경되는 부작용을 발생시킨다.
  var x = 10;
}

console.log(x); // 10
```

```javascript
var i = 10;

// for문에서 선언한 i는 전역 변수이다. 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.
for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}

// 의도치 않게 변수의 값이 변경되었다.
console.log(i); // 5
```



## 렉시컬 스코프

#### Dynamic Scope

함수를 어디서 호출했는지에 따라서 상위 스코프를 결정

#### Lexical Scope

함수를 어디서 정의했는지에 따라서 상위 스코프를 결정

대부분의 프로그래밍 언어는 렉시컬 스코프 사용

**모든 함수는 정의가 평가되어 함수 객체를 생성할 때 자신이 정의된 스코프를 내부 슬롯`[[Environment]]`에 저장한다.** 그리고 **함수가 호출되면 언제나 `[[Environment]]`에 저장된, 자신이 정의된 스코프를 상위 스코프로 사용**한다. 굉장히 중요한 개념이다!!!



## 암묵적 전역 변수 (implicit global)

```javascript
function foo() {
    x = 10;
}
```

자바스크립트에서 키워드 없이 변수를 선언하면 에러가 나는 것이 아니라 암묵적으로 전역 변수로 만들어버린다.

1. 이미 존재하는 전역 변수의 값을 변경시킬 수 있음
2. 다른 파일에 존재하는 전역 변수와 이름이 중복될 수 있음 (자바스크립트는 파일마다 독립적인 파일 스코프가 존재하지 않는다.)



# 전역 변수의 문제점

변수는 자신이 선언된 위치에서 생성되고 소멸한다. 

전역 변수의 생명 주기는 애플리케이션의 생명 주기와 같다. 

함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸한다. 

#### 암묵적 결합

모든 코드가 전역 변수를 참조하고 변경할 수 있는 **암묵적 결합(implicit coupling)**을 허용하는 것

변수의 유효 범위가 크면 클 수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아진다.

#### 긴 생명주기

생명주기가 길면 상태를 변경할 수 있는 시간과 기회가 많다. 메모리 리소스도 오래 소비한다.

#### 스코프 체인 상에서 종점에 존재

전역 변수의 검색 속도가 가장 느리다.

#### 네임 스페이스 오염

파일이 분리되어있어도 합쳐지면 하나의 전역 스코프를 이용하기 때문에 전역변수를 사용하면 문제가 생길 위험이 크다.



## 전역 변수 사용 억제 방법

#### 1. 즉시 실행 함수

모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다. 

#### 2. 네임 스페이스 객체

전역에 네임 스페이스 역할을 하는 객체를 생성하고 그 객체의 프로퍼티로 변수를 선언해 사용한다.

```javascript
var MYAPP = {}; // 전역 네임 스페이스 객체

MYAPP.name = 'subin';

console.log(MYAPP.name); // subin
```

#### 3. 모듈 패턴

클로저 기반. 전역변수 억제에 더해서 캡슐화 구현 가능

```javascript
var Counter = (function () {
  // private 변수
  var num = 0;

  // 외부로 공개할 데이터나 메소드를 프로퍼티로 추가한 객체를 반환한다.
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    }
  };
}());
```

Q. num은 자유변수인가?

Q. 즉시실행함수가 return할 객체를 생성하고 return할 때 객체 내부의 메소드 객체도 생성되기 때문에 생성 시에 실행 중이던 실행 컨텍스트의 렉시컬 스코프(즉시실행함수)를 기억해서 num에 접근할 수 있는 게 맞는지?

#### 4. ES6. 모듈

모듈 좋은데 Webpack 써야함