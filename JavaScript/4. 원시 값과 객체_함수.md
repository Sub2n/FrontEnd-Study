# 원시 값과 객체의 비교

## 1. 원시 값 (Primitive Value)

### 1.1 변경 불가능한 값 (immutable value)

원시 타입의 값은 변경 불가능한 값(immutable value)이다. 

값이 변경 불가능하다는 의미는 변수에 값을 재할당할 수 없다는 것과는 다르다. 변수가 가리키는 값은 실제로는 메모리에 저장되어있는데, 메모리에 적힌 값을 직접 변경할 수 없다는 뜻이다. 즉 immutable value는 read-only한 값이다.

### 1.2. 문자열과 불변성

자바스크립트는 문자열은 원시타입으로 제공한다. 자바스크립트의 문자열은 원시타입이며 따라서 변경 불가능(immutable)하다.

문자열은 유사배열이므로 index로 한 글자에 접근할 수 있다. 그러나 변경하려는 시도를 해도 원 문자열은 변경되지 않으며 이 때 **에러가 발생하지 않는다**.

### 1.3. 값에 의한 전달 (Pass by Value)

```javascript
const foo = 10;
const bar = foo;

console.log(foo === bar); // true
```

변수 foo와 변수 bar는 둘 다 10이라는 숫자 타입의 값을 가지지만, 실제로는 다른 메모리 공간에 저장된 별개의 값을 가리킨다.

원시 값은 어떤 변수의 값을 다른 변수에 할당할 때 메모리에 있는 값 자체를 복사해서 넘긴다. 이를 **깊은 복사(deep copy)**라고 한다.

## 2. 객체

### 2.1. 변경 가능한 값 (mutable value)

객체 타입의 값은 변경 가능하다. 위에서 변경 불가능하다는 것의 의미를 살펴보았다. 변경 가능하다는 것은 말 그대로 **메모리에 저장된 값을 직접 변경할 수 있음**을 의미한다.

**원시 값을 할당한 변수**는 **원시 값 자체**를 값으로 갖는다. 그러나 **객체를 할당한 변수**는 객체가 저장된 메모리 공간의 주소, 즉 **참조 값(Reference value)**을 값으로 갖는다.

객체는 생성된 이후에도 재할당을 하지 않고 프로퍼티를 동적으로 추가, 수정, 삭제할 수 있다. 이는 재할당을 하지 않으면 변경이 불가능한 원시 값과 구분되는 점이다.

### 2.1. 참조에 의한 전달 (Pass by Reference)

객체는 크기가 클 수 있고 프로퍼티의 값 또한 객체일 수 있어서 원시 값처럼 값 자체를 복사 (deep copy)하기에는 비용이 많이 든다. 따라서 객체는 객체가 저장된 메모리 주소를 전달한다. 이를 **참조에 의한 전달**이라고 한다.

참조에 의한 전달은 주의해야할 점이 있다. 각각 이름이 다른 변수가 같은 객체를 참조할 수 있기 때문이다. 이는 의도치 않게 객체를 변경할 가능성을 유발한다.



# 함수

## 1. 함수란?

프로그래밍에서 함수란 입력을 받아서 정의된 일련의 statement들을 수행하고 출력을 내보내는 것이다.

이 때 입력을 전달받는 변수를 매개변수(parameter), 입력을 인수(argument), 출력을 반환 값(return value)이라고 한다. 함수는 식별자로서 함수 명을 사용할 수 있다.

함수는 정의(definition)를 통해 생성하며 정의한 함수를 호출(call / invoke)해야 실행된다.

## 2. 함수를 사용하는 이유

**함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다.**

**코드의 가독성**을 향상

## 3. 함수 리터럴

함수는 함수 리터럴로 생성할 수 있다.

함수 리터럴 = function keyword, 함수명, parameter 목록, 함수 body로 구성

```javascript
const add = function add(x, y) {
    return x + y;
}
```

- 함수명
  - 식별자이므로 네이밍 규칙 준수
  - 함수명은 함수 body 내에서만 참조할 수 있는 식별자
  - 함수명은 생략 가능
- parameter
  - 0개 이상
  - parameter에는 argument가 할당됨
  - 함수 body 내에서 변수와 동일하게 취급
- 함수 body
  - 함수 호출에 의해 실행

자바스크립트에서 **함수는 객체**다. 

## 4. 함수 정의

함수를 정의하는 방법 4가지

- 함수 선언문 (Function Declaration)

  ```javascript
  function add(x, y) {
      return x + y;
  }
  ```

  함수 선언문은 **함수명이 필수**. 함수 선언문을 평가할 때 암묵적으로 함수명과 동일한 변수에 생성된 함수 객체를 할당하기 때문이다. 함수는 함수명이 아닌, **함수 명과 동일한 변수로 호출**한다.

- 함수 표현식 (Function Expression)

  ```javascript
  const add = function(x, y) {
      return x + y;
  }
  ```

  위 코드는 함수 표현식으로 생성한 함수를 변수 add에 할당한다.  이 변수로 함수를 호출한다.

  자바스크립트에서 함수는 일급 객체(first-class object)이므로 값처럼 할당할 수 있다.

- Function 생성자 함수 (Function Constructor)

  ```javascript
  const add = new Function('x', 'y', 'return x + y');
  ```

  거의 안씀

- 화살표 함수 (Arrow Function)

  ```javascript
  const add = () => x + y;
  ```

  화살표 함수로 정의한 함수는 함수 내부의 자기 참조 변수인 this를 할당하는 방식이 위의 것들과 다르다.

## 5. 함수 호이스팅과 변수 호이스팅

함수 선언문과 함수 표현식으로 생성하는 함수들은 호이스팅에서 차이가 있다.

호이스팅이란 변수, 함수 등의 선언문을 실행 이전에 먼저 평가해 마치 코드의 맨 위에서 선언된 것처럼 동작하는 것을 말한다.

함수 선언문은 선언문이므로 호이스팅이 되어 선언문 이전에도 참조하고 호출할 수 있지만,

함수 표현식은 함수명으로 사용할 변수에 함수 표현식으로 만든 함수 객체를 **할당하는 것**이기 때문에 할당문 이전에 호출하면 Type Error가 발생한다. undefined를 호출하는 것이기 때문이다.

## 즉시실행함수

```javascript
(function () {
  var a = 3;
  var b = 5;
  return a * b;
}());
```

외에도 재귀함수, 중첩 함수, 콜백 함수 등이 있다.. 자주 쓰인다 패턴을 알아두자